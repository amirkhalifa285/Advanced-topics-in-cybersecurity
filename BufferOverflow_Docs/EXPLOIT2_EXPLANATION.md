# How exploit-2.py Works - Complete Explanation

## Exercise 2 Success Summary

**Exploit File:** `exploit-2.py`  
**Target Vulnerability:** `url_decode()` function in `http.c`  
**Result:** Server crash with signal 11 (segmentation fault)

---

## Why The First Approach Failed

### Initial Target: http_serve() vulnerability
```c
// In http.c, line 282:
if (strlen(name) + strlen(pn) + 1 >= sizeof(pn)) {
    http_err(fd, 500, "Request too long");
    return;
}
strncat(pn, name, sizeof(pn) - strlen(pn) - 1);
```

**Problems:**
1. Length check limits input to ~1997 bytes
2. Current working directory (CWD) is 48 bytes
3. Total in buffer after strncat: 48 + 1997 = 2045 bytes
4. Distance to saved RIP: 2088 bytes
5. **Gap: 43 bytes SHORT of reaching saved RIP!**

**Conclusion:** This vulnerability alone cannot reach the return address due to the length check.

---

## Why The Working Exploit Succeeds

### Target: url_decode() vulnerability

**Location:** `http.c`, lines 441-471  
**Called from:** `http_request_line()` â†’ line 105

### The Vulnerable Code:

```c
void url_decode(char *dst, const char *src)
{
    for (;;)
    {
        if (src[0] == '%' && src[1] && src[2])
        {
            char hexbuf[3];
            hexbuf[0] = src[1];
            hexbuf[1] = src[2];
            hexbuf[2] = '\0';
            *dst = strtol(&hexbuf[0], 0, 16);
            src += 3;
        }
        else if (src[0] == '+')
        {
            *dst = ' ';
            src++;
        }
        else
        {
            *dst = *src;    // â† NO BOUNDS CHECK!
            src++;
            
            if (*dst == '\0')
                break;
        }
        
        dst++;              // â† Keeps incrementing forever!
    }
}
```

### The Critical Flaw:

**NO bounds checking on `dst`!**

The function blindly writes to `dst` until it finds a null terminator in `src`. If `src` is very long, it will overflow `dst`.

### The Call Chain:

```
1. Attacker sends: GET /AAAA...[8000 A's]...AAAA HTTP/1.0

2. zookd receives connection â†’ fork() â†’ process_client()

3. process_client() declares:
   char reqpath[4096];  â† Only 4096 bytes!

4. Calls: http_request_line(fd, reqpath, ...)

5. http_request_line() calls:
   url_decode(reqpath, sp1);  â† sp1 points to URL path

6. url_decode() writes 8000 bytes into 4096-byte buffer!

7. OVERFLOW! Stack corrupted!

8. Crash! Signal 11 (SIGSEGV)
```

---

## exploit-2.py Strategy

### Simple and Effective:

```python
payload_size = 8000          # Much larger than buffer
payload = b"A" * payload_size

request = b"GET /" + payload + b" HTTP/1.0\r\n\r\n"
```

**Why 8000 bytes?**
- Buffer size: 4096 bytes
- Overflow needed: 4000 bytes (nearly double the buffer)
- Guaranteed to overwrite stack data including return addresses
- Simple 'A' characters (0x41) - no URL encoding needed

### What Gets Overwritten:

```
Stack in process_client():

[reqpath: 4096 bytes]    â† Starts here
[overflow continues...]  â† Bytes 4097-8000 overwrite:
  - Local variables
  - Saved frame pointer (RBP)
  - Saved return address (RIP)  â† CRITICAL!
  - Other stack data
```

When the function tries to return, it loads the corrupted RIP (now filled with 0x41414141) and crashes!

---

## Evidence of Success

### Terminal Output:
```
Child process 181041 terminated incorrectly, receiving signal 11
```

### dmesg Output:
```
traps: zookd[181041] general protection fault ip:7f5e27d48f9c sp:7ffc21961ed8 error:0 in libc.so.6
```

**Breakdown:**
- **general protection fault**: CPU detected invalid memory access
- **ip:7f5e27d48f9c**: Instruction pointer in libc (crashed in C library function)
- **sp:7ffc21961ed8**: Stack pointer (near our overflow location)
- **error:0**: Memory access violation (not permissions issue)

### Why It Crashes in libc:

After the overflow corrupts the stack, when `process_client()` tries to:
1. Call another function (like `strlen()` or `strcmp()`)
2. Or return to its caller

It uses the corrupted return address (filled with 0x41414141), jumps to invalid memory, and crashes!

---

## Key Differences: Working vs Failed Approach

| Aspect | http_serve() (Failed) | url_decode() (Success) |
|--------|----------------------|------------------------|
| **Location** | http.c line 282 | http.c line 441 |
| **Buffer Size** | 2048 bytes (pn) | 4096 bytes (reqpath) |
| **Length Check** | Yes (prevents exploit) | **NO** (vulnerable!) |
| **Max Input** | ~1997 bytes | Unlimited! |
| **Can Reach RIP** | No (43 bytes short) | Yes (4000+ byte overflow) |
| **Exploit Complexity** | High (need exact offsets) | Low (just send lots of data) |

---

## Why url_decode() Has No Check

Looking at the code flow:

1. `http_read_line()` reads from socket into 8192-byte static buffer
2. HTTP request line is parsed
3. URL path extracted (between first and second space)
4. `url_decode(reqpath, url_path)` called

**The assumption:** HTTP request line is limited by `http_read_line()` to 8192 bytes, and URL path is part of that, so it "should" fit in the 4096-byte `reqpath` buffer.

**The reality:** This assumption is WRONG! The URL path can be much larger than 4096 bytes and still fit in the 8192-byte read buffer!

---

## Lessons Learned

### 1. Multiple Vulnerabilities
A codebase can have multiple buffer overflow vulnerabilities. Some are easier to exploit than others.

### 2. Length Checks Matter
The `http_serve()` vulnerability has a length check (even though flawed), making it much harder to exploit. The `url_decode()` vulnerability has NO check, making it trivial.

### 3. Defense in Depth
Even with the length check in `http_serve()`, the code is still vulnerable because:
- Check uses `>=` instead of `>`
- `strncat()` is error-prone
- No stack canaries
- No ASLR (in this lab environment)

### 4. Simpler is Better
When multiple vulnerabilities exist, exploit the simplest one!
- url_decode(): Send 8000 'A's â†’ crash
- http_serve(): Calculate exact offsets, bypass checks â†’ limited success

---

## Summary

**exploit-2.py works because:**
1. âœ… Targets `url_decode()` - NO bounds checking
2. âœ… Sends 8000 bytes into 4096-byte buffer  
3. âœ… Overflows stack by ~4000 bytes
4. âœ… Corrupts saved return address
5. âœ… Server crashes with signal 11

**Simple, reliable, and effective!** ðŸŽ¯

---

## Files Location

All buffer overflow documentation is now in:
```
~/Desktop/Advanced_cyber/lab/lab/BufferOverflow_Docs/
```

Contents:
- BUFFER_OVERFLOW_ANALYSIS.md - Complete technical analysis
- EXERCISE1_SUMMARY.md - Quick reference
- STACK_DIAGRAM.txt - Visual stack layouts
- DEMONSTRATION_GUIDE.md - Demo script
- README_EXERCISE1.md - Master index
- EXPLOIT_INSTRUCTIONS.md - Testing guide
- EXPLOIT2_EXPLANATION.md - This file

**Working exploit:**
```
~/Desktop/Advanced_cyber/lab/lab/exploit-2.py
```

---

**End of Explanation**
